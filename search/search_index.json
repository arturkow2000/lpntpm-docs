{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About lpnTPM is Open Source Software (OSS), and Open Source Hardware (OSHW) Trusted Platform Module (TPM, also known as ISO/IEC 11889) is an international standard for a secure cryptoprocessor, a dedicated microcontroller designed to secure hardware through integrated cryptographic keys. What makes lpnTPM different from generally available solutions is openness. Software and hardware of lpnTPM can, without limits, be audited, fixed, and customized by communities and businesses. Open design address the lack of trustworthiness of proprietary closed source TPM products, which currently dominate the whole market. lpnTPM in production mode protects software by secure boot technology, and only the lpnTPM owner will update it. TPM modules enable measured boot and support verified boot, Dynamic Root of Trust for Measurement, and other security features. Another benefit of lpnTPM would be physical design, which solves the lack of standardization around pinout and connector. The ultimate goal of lpnTPM is to provide a trustworthy platform for future open evolution of Trusted Platform Module software and its application to various computing devices, resulting in better adoption of platform security. This project was funded through the NGI Assure Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 957073.","title":"About"},{"location":"#about","text":"lpnTPM is Open Source Software (OSS), and Open Source Hardware (OSHW) Trusted Platform Module (TPM, also known as ISO/IEC 11889) is an international standard for a secure cryptoprocessor, a dedicated microcontroller designed to secure hardware through integrated cryptographic keys. What makes lpnTPM different from generally available solutions is openness. Software and hardware of lpnTPM can, without limits, be audited, fixed, and customized by communities and businesses. Open design address the lack of trustworthiness of proprietary closed source TPM products, which currently dominate the whole market. lpnTPM in production mode protects software by secure boot technology, and only the lpnTPM owner will update it. TPM modules enable measured boot and support verified boot, Dynamic Root of Trust for Measurement, and other security features. Another benefit of lpnTPM would be physical design, which solves the lack of standardization around pinout and connector. The ultimate goal of lpnTPM is to provide a trustworthy platform for future open evolution of Trusted Platform Module software and its application to various computing devices, resulting in better adoption of platform security. This project was funded through the NGI Assure Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 957073.","title":"About"},{"location":"building/","text":"Building, flashing, and debugging Build Here you can find our fork of Official TPM 2.0 Reference Implementation (by Microsoft) . The project is developed using STM32CubeIDE so the building process is straightforward. Just clone it with git... git clone --recurse-submodules git@github.com:lpn-plant/ms-tpm-20-ref.git cd ms-tpm-20-ref git checkout cmd_parsing git submodule update ... and import it using Import -> Existing Project into Workspace in IDE Project Explorer . Select Nucleo-L476RG project from ms-tpm-20-ref/Samples/Nucleo-TPM/L476RG directory. Flash and Debug To flash/debug the application click on the green bug icon on the top toolbar and select Nucleo-L476RG Debug . If you cannot see it, select Debug Configuration... and it should be listed under STM32 Cortex-M C/C++ Application menu selection. Some extra tweaks were necessary to enable SWV ITM traces, other than that we are using the default STLink debug configuration. IDE debug configuration file is included in project root dir and should be automatically available Nucleo-L476RG Debug.launch .","title":"Building flashing and debugging"},{"location":"building/#building-flashing-and-debugging","text":"","title":"Building, flashing, and debugging"},{"location":"building/#build","text":"Here you can find our fork of Official TPM 2.0 Reference Implementation (by Microsoft) . The project is developed using STM32CubeIDE so the building process is straightforward. Just clone it with git... git clone --recurse-submodules git@github.com:lpn-plant/ms-tpm-20-ref.git cd ms-tpm-20-ref git checkout cmd_parsing git submodule update ... and import it using Import -> Existing Project into Workspace in IDE Project Explorer . Select Nucleo-L476RG project from ms-tpm-20-ref/Samples/Nucleo-TPM/L476RG directory.","title":"Build"},{"location":"building/#flash-and-debug","text":"To flash/debug the application click on the green bug icon on the top toolbar and select Nucleo-L476RG Debug . If you cannot see it, select Debug Configuration... and it should be listed under STM32 Cortex-M C/C++ Application menu selection. Some extra tweaks were necessary to enable SWV ITM traces, other than that we are using the default STLink debug configuration. IDE debug configuration file is included in project root dir and should be automatically available Nucleo-L476RG Debug.launch .","title":"Flash and Debug"},{"location":"further_project_development/","text":"Further TPM Project development investigation If we are going to plan further project development, we have to solve issues that appears in current work with project. The main issues are: + Lack of RAM memory in CPU + Rather low frequency of MCU clock In order to overcome that issues we have to choose more powerful microcontroller. Planned further implementation of LPC protocol on MCU require higher clock frequency (above 100 Mhz). In current project static code analysis shows RAM memory occupancy above 96 percent. Current project code analysis in terms of hardware dependence We start project code analysis (Nucleo-L476RG) with basic files defining hardware components. Catalog \"Src\" - basic files: system_stm32l4xx.c In this file are defined major hardware parameters: clock frequency, SRAM, FPU. It can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. 2. stm32l4xx_hal_msp.c In this file is located code for initialisation of hardware modules and peripherals. It can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family stm32l4xx_it.c This file includes hardware components and peripherals interrupt handlers routines. In this file is located code for initialisation of hardware modules and peripherals. It can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. main.c This file is application starter and includes also hardware initialisation procedures. Here are hardware initialisation functions: void SystemClock_Config(void); static void MX_GPIO_Init(void); static void MX_RNG_Init(void); static void MX_RTC_Init(void); static void MX_USART2_UART_Init(void); These functions can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. Remaining code files in this catalog are related to USB CDC device and could be removed after going on SPI or LPC protocol. Catalog \"startup\" is generated automaticaly during creating new project by \"STM32CubeMX\". Catalog \"Inc\" contains header files for major code files in project: stm32l4xx_it.h stm32l4xx_hal_conf.h main.h These files can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. There also are located header files for USB device, which could be removed removed after going on SPI or LPC protocol. In sub-catalogs Platform TPMCmd TPMDevice there are located header files related to reference implementation of TPM (Microsoft) - these files are not dependent of hardware. In \"Drivers\" catalog are located basic hardware layer drivers: CMSIS STM32L4xx_HAL_Driver These catalogs are automaticaly copied to project during creating of project. In the case of choosing of different MCU (not STM32 family) the CMSIS drivers also would be copied to project, but HAL library can be quite different. \u201cMiddlewares\u201d catalog includes major implementation of TPM (Microsoft company) and also implemantation of USB device. USB library code is located in: ST \u2192 STM32_USB_Device_Library TPM implementation is located in sub-catalogs: Platform TPMCmd TPMDevice wolfcrypt TPM implementation is independent from hardware. \"Includes\" catalod includes headers related to CMSIS library, HAL library, USB device and TPM. This code is related of hardware and might be most difficult to write for different MCU. Target hardware platform for TPM (ARM) project The major difficulty for choosing new hardware platform (MCU) is current unavailability of semiconductors, so the major criterion is availability of particular MCU. New MCU have to let overcome issues described in the beginning of this document. In this purpose we made such assumptiuons for new MCU: MCU : ARM-Cortex-M4 clock frequency from 168 Mhz to 200 Mhz LQFP64 case SRAM amount from 192 KB to 256 KB We choose device with ARM Cortex-M4 from \"GigaDevice\" company. Here is link to search engine on \"Gigadevice\" WWW page: High performance GD32 ARM Cirtex-M4 Microcontrollers The best candidate for new MCU seems this particular device: GD32F425RGT6 The \"GigaDevice\" company also provides basic firmware: CMSIS library and few tools (for example programer, profiler). The reference IDE/Compiler for these GD32 MCU is \"Keil uVision\" (\"Segger Studio for ARM\" is also on list). There is also hardware programmer/debugger (JTAG) available. There is one difficulty with this GD32F4xx MCU family, there is not available \"HAL\" library for these devices. \"Gigadevice\" company id providing instead \"HAL\" libraries \"Standard Peripheral\" libray. \"Standard Peripheral\" libray was higher-level hardware abstraction library, before ST company write newer \"HAL\" library. \"Standard Peripheral\" library is from several years deprecated and what worse it's API is different from \"HAL\" API. This fact has impact on time estitmate for re-writing code for new MCU - all hardware dependent code have to be re-writing. So time estimates will be higher.","title":"Further TPM Project development investigation"},{"location":"further_project_development/#further-tpm-project-development-investigation","text":"If we are going to plan further project development, we have to solve issues that appears in current work with project. The main issues are: + Lack of RAM memory in CPU + Rather low frequency of MCU clock In order to overcome that issues we have to choose more powerful microcontroller. Planned further implementation of LPC protocol on MCU require higher clock frequency (above 100 Mhz). In current project static code analysis shows RAM memory occupancy above 96 percent.","title":"Further TPM Project development investigation"},{"location":"further_project_development/#current-project-code-analysis-in-terms-of-hardware-dependence","text":"We start project code analysis (Nucleo-L476RG) with basic files defining hardware components. Catalog \"Src\" - basic files: system_stm32l4xx.c In this file are defined major hardware parameters: clock frequency, SRAM, FPU. It can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. 2. stm32l4xx_hal_msp.c In this file is located code for initialisation of hardware modules and peripherals. It can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family stm32l4xx_it.c This file includes hardware components and peripherals interrupt handlers routines. In this file is located code for initialisation of hardware modules and peripherals. It can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. main.c This file is application starter and includes also hardware initialisation procedures. Here are hardware initialisation functions: void SystemClock_Config(void); static void MX_GPIO_Init(void); static void MX_RNG_Init(void); static void MX_RTC_Init(void); static void MX_USART2_UART_Init(void); These functions can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. Remaining code files in this catalog are related to USB CDC device and could be removed after going on SPI or LPC protocol. Catalog \"startup\" is generated automaticaly during creating new project by \"STM32CubeMX\". Catalog \"Inc\" contains header files for major code files in project: stm32l4xx_it.h stm32l4xx_hal_conf.h main.h These files can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. There also are located header files for USB device, which could be removed removed after going on SPI or LPC protocol. In sub-catalogs Platform TPMCmd TPMDevice there are located header files related to reference implementation of TPM (Microsoft) - these files are not dependent of hardware. In \"Drivers\" catalog are located basic hardware layer drivers: CMSIS STM32L4xx_HAL_Driver These catalogs are automaticaly copied to project during creating of project. In the case of choosing of different MCU (not STM32 family) the CMSIS drivers also would be copied to project, but HAL library can be quite different. \u201cMiddlewares\u201d catalog includes major implementation of TPM (Microsoft company) and also implemantation of USB device. USB library code is located in: ST \u2192 STM32_USB_Device_Library TPM implementation is located in sub-catalogs: Platform TPMCmd TPMDevice wolfcrypt TPM implementation is independent from hardware. \"Includes\" catalod includes headers related to CMSIS library, HAL library, USB device and TPM. This code is related of hardware and might be most difficult to write for different MCU.","title":"Current project code analysis in terms of hardware dependence"},{"location":"further_project_development/#target-hardware-platform-for-tpm-arm-project","text":"The major difficulty for choosing new hardware platform (MCU) is current unavailability of semiconductors, so the major criterion is availability of particular MCU. New MCU have to let overcome issues described in the beginning of this document. In this purpose we made such assumptiuons for new MCU: MCU : ARM-Cortex-M4 clock frequency from 168 Mhz to 200 Mhz LQFP64 case SRAM amount from 192 KB to 256 KB We choose device with ARM Cortex-M4 from \"GigaDevice\" company. Here is link to search engine on \"Gigadevice\" WWW page: High performance GD32 ARM Cirtex-M4 Microcontrollers The best candidate for new MCU seems this particular device: GD32F425RGT6 The \"GigaDevice\" company also provides basic firmware: CMSIS library and few tools (for example programer, profiler). The reference IDE/Compiler for these GD32 MCU is \"Keil uVision\" (\"Segger Studio for ARM\" is also on list). There is also hardware programmer/debugger (JTAG) available. There is one difficulty with this GD32F4xx MCU family, there is not available \"HAL\" library for these devices. \"Gigadevice\" company id providing instead \"HAL\" libraries \"Standard Peripheral\" libray. \"Standard Peripheral\" libray was higher-level hardware abstraction library, before ST company write newer \"HAL\" library. \"Standard Peripheral\" library is from several years deprecated and what worse it's API is different from \"HAL\" API. This fact has impact on time estitmate for re-writing code for new MCU - all hardware dependent code have to be re-writing. So time estimates will be higher.","title":"Target hardware platform for TPM (ARM) project"},{"location":"hardware_interfaces/","text":"Target TPM hardware interfaces As we are designing a universal TPM device, we are targeting multiple communication interfaces to talk to TPM. Our requirements are to use the most popular ones (LPC and SPI). The first interface, that we are looking to implement is SPI. That's mostly because we think it is the easiest way to start. We are planning to use lpnTPM with an embedded platform (such as Raspberry Pi) for test purposes. Some steps were made to archive it, but we are still in the development stage. Our goal is to be able to use tpm2-tools and emulate the behavior of already available TPM. Required SPI bus speed As one of our requirements is to communicate with motherboards using SPI, we should also implement such communication. TCG PC Client Platform TPM Profile Specification for TPM 2.0 document greatly explains the actual requirements of SPI interface. On page 127 in the 7.4.1 Clocking section, we can find the following must-have conditions for SPI bus speed. 1. The TPM SHALL support an SPI clock frequency range of 10 - 24MHz. 2. The TPM MAY support running at lower frequencies. 3. The TPM SHOULD support higher frequencies Let's focus on STM32L476 and its integrated SPI peripheral. As mentioned on page 1450 of the STM32 RM0351 Reference manual STM32L4 limits SPI speed up to APB2/2 , thus our maximum speed of the SPI interface is 40MHz. 42.2 SPI main features: - Slave mode frequency up to fPCLK/2 Taking into account the TPM requirements we should be good to initiate communication. Low pin count interface LPC (Low Pin Count) interface is not available in popular microcontrollers. We have some ideas for software implementations of such. First of all, we would like to use some other hardware interfaces, to be able to emulate this interface and initialize correct communication. We found some interesting software that somehow could help us to start thinking of software-based LPC bus emulation: State machine IO driver for the Low-Pin Count bus slave. STM32 available interfaces We will look towards FSMC , SPI , and 4-bit SDcard interface . There is a chance, that by preparing special data packets we can simulate the behavior of the LPC interface using a more popular one. In our opinion bit-banging of such a fast interface (33MHz) will not be reasonable and will require us to choose a faster processor, as STM32L4 runs at a maximum 80MHz. We have found an example of Low-Pin Count bus slave state machine IO driver so it can be a great starting point for our development of software emulation of the LPC bus. The actual throughput of LPC bus is 2.47MB - Table 18: Peripheral Initiated Memory Read Cycle so in case of bit-banging of the LPC interface we have to choose a microcontroller like STM32G4 Series with the maximum CPU clock speed of 170 MHz. Using SPI/LPC converters From what we found the one and only chip converter that is out there, to convert SPI to LPC is Microchip ECE1200 It uses Enhanced Serial Peripheral Interface (eSPI) , which is a slightly modified version of the SPI interface. This outcome and FPGA one, listed below would reduce the need for main uC computing power. Custom made FPGA converter Lattice software stack offers LPC implementation for FPGA's and if we want to implement it that way, it would be a clear and elegant solution to create some kind of SPI>LPC converter. Lattice XO2 series, avaliable in WLCSP25/WLCSP36 package (2,5mm x 2,5mm) would be sufficient.","title":"Target TPM hardware interfaces"},{"location":"hardware_interfaces/#target-tpm-hardware-interfaces","text":"As we are designing a universal TPM device, we are targeting multiple communication interfaces to talk to TPM. Our requirements are to use the most popular ones (LPC and SPI). The first interface, that we are looking to implement is SPI. That's mostly because we think it is the easiest way to start. We are planning to use lpnTPM with an embedded platform (such as Raspberry Pi) for test purposes. Some steps were made to archive it, but we are still in the development stage. Our goal is to be able to use tpm2-tools and emulate the behavior of already available TPM.","title":"Target TPM hardware interfaces"},{"location":"hardware_interfaces/#required-spi-bus-speed","text":"As one of our requirements is to communicate with motherboards using SPI, we should also implement such communication. TCG PC Client Platform TPM Profile Specification for TPM 2.0 document greatly explains the actual requirements of SPI interface. On page 127 in the 7.4.1 Clocking section, we can find the following must-have conditions for SPI bus speed. 1. The TPM SHALL support an SPI clock frequency range of 10 - 24MHz. 2. The TPM MAY support running at lower frequencies. 3. The TPM SHOULD support higher frequencies Let's focus on STM32L476 and its integrated SPI peripheral. As mentioned on page 1450 of the STM32 RM0351 Reference manual STM32L4 limits SPI speed up to APB2/2 , thus our maximum speed of the SPI interface is 40MHz. 42.2 SPI main features: - Slave mode frequency up to fPCLK/2 Taking into account the TPM requirements we should be good to initiate communication.","title":"Required SPI bus speed"},{"location":"hardware_interfaces/#low-pin-count-interface","text":"LPC (Low Pin Count) interface is not available in popular microcontrollers. We have some ideas for software implementations of such. First of all, we would like to use some other hardware interfaces, to be able to emulate this interface and initialize correct communication. We found some interesting software that somehow could help us to start thinking of software-based LPC bus emulation: State machine IO driver for the Low-Pin Count bus slave.","title":"Low pin count interface"},{"location":"hardware_interfaces/#stm32-available-interfaces","text":"We will look towards FSMC , SPI , and 4-bit SDcard interface . There is a chance, that by preparing special data packets we can simulate the behavior of the LPC interface using a more popular one. In our opinion bit-banging of such a fast interface (33MHz) will not be reasonable and will require us to choose a faster processor, as STM32L4 runs at a maximum 80MHz. We have found an example of Low-Pin Count bus slave state machine IO driver so it can be a great starting point for our development of software emulation of the LPC bus. The actual throughput of LPC bus is 2.47MB - Table 18: Peripheral Initiated Memory Read Cycle so in case of bit-banging of the LPC interface we have to choose a microcontroller like STM32G4 Series with the maximum CPU clock speed of 170 MHz.","title":"STM32 available interfaces"},{"location":"hardware_interfaces/#using-spilpc-converters","text":"From what we found the one and only chip converter that is out there, to convert SPI to LPC is Microchip ECE1200 It uses Enhanced Serial Peripheral Interface (eSPI) , which is a slightly modified version of the SPI interface. This outcome and FPGA one, listed below would reduce the need for main uC computing power.","title":"Using SPI/LPC converters"},{"location":"hardware_interfaces/#custom-made-fpga-converter","text":"Lattice software stack offers LPC implementation for FPGA's and if we want to implement it that way, it would be a clear and elegant solution to create some kind of SPI>LPC converter. Lattice XO2 series, avaliable in WLCSP25/WLCSP36 package (2,5mm x 2,5mm) would be sufficient.","title":"Custom made FPGA converter"},{"location":"how_to/","text":"How to lpnTPM is developed around Official TPM 2.0 Reference Implementation (by Microsoft) . The project consists of a cross-platform simulator and samples both for Cortex M and Cortex A. The original port was developed on STM32L4A6RG and STM32L476RG microcontrollers using Atollic Studio. For future compatibility, we converted project files to STM32CubeIDE , which is a successor of Atollic software. The project doesn't provide any other build systems but we are definitely looking forward to use one. During the early development stage, we are using Nucleo L476RG board with USB cable connected to STM32 IO. Due to the limited amount of SRAM memory of such uC soon we will probably switch to a different one. We are currently looking at L4/F4 series in LQFP64 package. Probably for convenience, we will use some ready-made dev board as Nucleo L452RE with 160 KB of SRAM. At the current stage of development, we are using Nucleo USB CDC port to communicate to TPM core. We are targetting different interfaces - SPI, I2C, LPC is a must. STlink integrated serial port, as well as ITM traces, are used for debugging purposes.","title":"Intro"},{"location":"how_to/#how-to","text":"lpnTPM is developed around Official TPM 2.0 Reference Implementation (by Microsoft) . The project consists of a cross-platform simulator and samples both for Cortex M and Cortex A. The original port was developed on STM32L4A6RG and STM32L476RG microcontrollers using Atollic Studio. For future compatibility, we converted project files to STM32CubeIDE , which is a successor of Atollic software. The project doesn't provide any other build systems but we are definitely looking forward to use one. During the early development stage, we are using Nucleo L476RG board with USB cable connected to STM32 IO. Due to the limited amount of SRAM memory of such uC soon we will probably switch to a different one. We are currently looking at L4/F4 series in LQFP64 package. Probably for convenience, we will use some ready-made dev board as Nucleo L452RE with 160 KB of SRAM. At the current stage of development, we are using Nucleo USB CDC port to communicate to TPM core. We are targetting different interfaces - SPI, I2C, LPC is a must. STlink integrated serial port, as well as ITM traces, are used for debugging purposes.","title":"How to"},{"location":"instrumentation/","text":"TPM driver instrumentation For development purposes, a set of scripts was created that allows for the instrumentation of a specific module, allowing for tracing the execution of module functions. This could be especially useful in the process of development of different protocol backends in our lpntpn like LPC or I2C. For now, scripts are located inside our fork of ms-tpm-20-ref repository. Look for Samples/Nucleo-TPM/scripts/kfunc_tracer directory on the dev branch. We use the integrated functionality that gcc provides '-finstrument-function' for function instrumentation. This step allows us to register exact function call addresses and log them to dmesg. Next, we match the function addresses against kernel processes address space that's located in /proc/modules to identify loaded module, that fn call belongs to. By subtracting function address with start memory location of loaded module, we obtain the real offset of a function call, that could be easily matched with an exact function name. The last step is to extract functions memory offsets located in non-striped kernel modules. For this purpose we are using a simple readelf call: readelf -s MODULE_NAME.ko | grep FUNC . This process requires kernel recompilation, execution of module startup and parsing of resulting trace files. Prepare Raspberry Pi We are using Raspberry Pi 3, but with minor modifications, this process could be used on different targets. Flash SD card with raspbian lite os. At the moment of writing image 2021-05-07-raspios-buster-armhf-lite.img was used. Enable ssh. Execute on raspberry pi with connected keyboard and display # upgrade sudo apt update sudo apt upgrade # change default password passwd # enable ssh sudo systemctl enable ssh sudo systemctl start ssh Check ssh connection. Environmental variable RASPI_IP will be used several more times during this guide. Run on your host machine to test ssh connection. export RASPI_IP = pi@192.168.8.170 ssh-copy-id -i ~/.ssh/id_rsa.pub $RASPI_IP ssh $RASPI_IP echo \"success\" # should echo success without prompting user to enter password Kernel compilation Prepare build environment. Ubuntu 20.04 LTS was used in this example. Install dependencies on your host machine and get source code. sudo apt install crossbuild-essential-armhf # default toolchain sudo apt install python-is-python3 # no python2 in ubuntu 20 fix sudo apt install bison flex sudo apt install qtbase5-dev pkg-config # xconfig sudo apt install libncurses5-dev # menuconfig cd git git clone --depth = 1 https://github.com/raspberrypi/linux cd linux # at the moment of writing we are using rpi-5.10.y branch specifically # 581049d718caf95f5feb00607ac748d5841cf27c commit git checkout 581049d718caf95f5feb00607ac748d5841cf27c Patch kernel For future debug output we add CONFIG_DYNAMIC_DEBUG=y to bcm2709_defconfig. The rest of this patch is the code instrumentation functions themself. instrument.patch Build kernel On your host machine: cd git cd linux export KERNEL = kernel7 # output build directories export BUILD_DIR = build export INSTALL_PATH = install_tmp # temp directory for new content of the /boot and /root partion export BOOT_PART_TMP = $BUILD_DIR / $INSTALL_PATH /boot # make modules_install will create build/install_tmp/root/lib directory during # install. we dont need to specify $BUILD_DIR prefix export ROOT_PART_TMP = $INSTALL_PATH /root # prepare output directory mkdir -p $BOOT_PART_TMP mkdir -p $BOOT_PART_TMP /overlays make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR bcm2709_defconfig make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR scripts prepare modules_prepare make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR zImage modules dtbs make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR modules_install INSTALL_MOD_PATH = $ROOT_PART_TMP # export K_VERSION variable export K_VERSION = $( make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- O = $BUILD_DIR -s kernelrelease ) cp $BUILD_DIR /arch/arm/boot/zImage $BOOT_PART_TMP / $KERNEL .img cp $BUILD_DIR /arch/arm/boot/dts/*.dtb $BOOT_PART_TMP cp $BUILD_DIR /arch/arm/boot/dts/overlays/*.dtb $BOOT_PART_TMP /overlays Deploy On your host machine: export PI_HOME = /home/pi cd ~/git/linux tar -zcvf install_pkg.tar.gz $BUILD_DIR / $INSTALL_PATH scp install_pkg.tar.gz $RASPI_IP :/home/pi/ ssh $RASPI_IP tar -xvzf $PI_HOME /install_pkg.tar.gz ssh $RASPI_IP rm $PI_HOME /install_pkg.tar.gz ssh $RASPI_IP sudo cp -r $PI_HOME /build/install_tmp/root/lib/* /lib ssh $RASPI_IP sudo cp -r $PI_HOME /build/install_tmp/boot/* /boot ssh $RASPI_IP rm -rf $PI_HOME /build ssh $RASPI_IP sudo reboot Test if dynamic debug option is enabled ssh $RASPI_IP sudo modprobe configs ssh $RASPI_IP \"zcat /proc/config.gz | grep DYNAMIC_DEBUG\" # you should get the following output: # CONFIG_DYNAMIC_DEBUG=y # CONFIG_DYNAMIC_DEBUG_CORE=y Build instrumented module cd ~/git/linux export BUILD_DIR = build export K_VERSION = $( make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- O = $BUILD_DIR -s kernelrelease ) make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR -C . M = drivers/char/tpm EXTRA_CFLAGS = \"-g -DDEBUG=1 -finstrument-functions\" export MOD_SRC = build/drivers/char/tpm export MOD_TMP_DST = /home/pi export MOD_DST = /lib/modules/ $K_VERSION /kernel/drivers/char/tpm scp $MOD_SRC /tpm.ko $RASPI_IP : $MOD_TMP_DST / scp $MOD_SRC /tpm_tis_core.ko $RASPI_IP : $MOD_TMP_DST scp $MOD_SRC /tpm_tis_spi.ko $RASPI_IP : $MOD_TMP_DST ssh $RASPI_IP sudo mv tpm.ko $MOD_DST ; ssh $RASPI_IP sudo mv tpm_tis_core.ko $MOD_DST ; ssh $RASPI_IP sudo mv tpm_tis_spi.ko $MOD_DST ; At this point, we need to enable device tree overlay for tpm. In Raspberry Pi ssh terminal: sudo nano /boot/config.txt # add at the bottom dtparam = spi = on dtoverlay = tpm-slb9670 # permanently enable debug log level sudo nano /boot/cmdline.txt add 'loglevel=7' at the end of the line # reboot raspi sudo reboot At this point, just after raspi reboot you should be able to see tpm function traces in dmesg . Example trace: In Raspberry Pi ssh terminal: $ dmesg | grep tpm_addr [ 9.358361] tpm_addr_enter: 0x7f0ee070 0x801022a4 [ 9.358546] tpm_addr_enter: 0x7f0ee000 0x7f0ee15c [ 9.359167] tpm_addr_exit: 0x7f0ee000 0x7f0ee15c [ 9.359180] tpm_addr_exit: 0x7f0ee070 0x801022a4 [ 9.420744] tpm_addr_enter: 0x7f09f000 0x801022a4 Collect traces and get function names from addresses Last step to get execution traces is to use provided scripts located in ms-tpm-20-ref/Samples/Nucleo-TPM/scripts/kfunc_tracer Pull logs from your host machine: $ ./pull_logs.sh RASPI_IP: pi@192.168.8.170 creating ./logs directory entering ./logs directory cleaning ./logs directory collecting dmesg tpm_addr logs collecting tpm related /proc/modules entries Get function names. Below you can see the full call stack of tpm module failing due to not connected hardware of tpm module. To be executed on your host machine. $ python get_call_stack.py tpm_tis_spi.ko: tpm_tis_spi_driver_probe() tpm_tis_spi.ko: tpm_tis_spi_probe() tpm_tis_spi.ko: tpm_tis_spi_init() tpm_tis_core.ko: tpm_tis_core_init() tpm.ko: tpmm_chip_alloc() tpm.ko: tpm_chip_alloc() tpm.ko: tpm2_init_space() tpm.ko: tpm2_init_space() tpm.ko: tpm_chip_alloc() tpm.ko: tpmm_chip_alloc() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: wait_startup() tpm_tis_spi.ko: tpm_tis_spi_read_bytes() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_read_bytes() tpm_tis_core.ko: wait_startup() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_remove() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_spi.ko: tpm_tis_spi_read32() tpm_tis_spi.ko: tpm_tis_spi_read_bytes() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_read_bytes() tpm_tis_spi.ko: tpm_tis_spi_read32() tpm_tis_spi.ko: tpm_tis_spi_write32() tpm_tis_spi.ko: tpm_tis_spi_write_bytes() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_write_bytes() tpm_tis_spi.ko: tpm_tis_spi_write32() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_remove() tpm_tis_core.ko: tpm_tis_core_init() tpm_tis_spi.ko: tpm_tis_spi_init() tpm_tis_spi.ko: tpm_tis_spi_probe() tpm_tis_spi.ko: tpm_tis_spi_driver_probe() tpm.ko: tpm_dev_release() tpm.ko: tpm_dev_release() Whole logs from the test procedure Below we have collected call stack for Raspberry Pi TPM driver startup. Log file with TPM module plugged in Log file without TPM","title":"TPM driver instrumentation"},{"location":"instrumentation/#tpm-driver-instrumentation","text":"For development purposes, a set of scripts was created that allows for the instrumentation of a specific module, allowing for tracing the execution of module functions. This could be especially useful in the process of development of different protocol backends in our lpntpn like LPC or I2C. For now, scripts are located inside our fork of ms-tpm-20-ref repository. Look for Samples/Nucleo-TPM/scripts/kfunc_tracer directory on the dev branch. We use the integrated functionality that gcc provides '-finstrument-function' for function instrumentation. This step allows us to register exact function call addresses and log them to dmesg. Next, we match the function addresses against kernel processes address space that's located in /proc/modules to identify loaded module, that fn call belongs to. By subtracting function address with start memory location of loaded module, we obtain the real offset of a function call, that could be easily matched with an exact function name. The last step is to extract functions memory offsets located in non-striped kernel modules. For this purpose we are using a simple readelf call: readelf -s MODULE_NAME.ko | grep FUNC . This process requires kernel recompilation, execution of module startup and parsing of resulting trace files.","title":"TPM driver instrumentation"},{"location":"instrumentation/#prepare-raspberry-pi","text":"We are using Raspberry Pi 3, but with minor modifications, this process could be used on different targets. Flash SD card with raspbian lite os. At the moment of writing image 2021-05-07-raspios-buster-armhf-lite.img was used. Enable ssh. Execute on raspberry pi with connected keyboard and display # upgrade sudo apt update sudo apt upgrade # change default password passwd # enable ssh sudo systemctl enable ssh sudo systemctl start ssh Check ssh connection. Environmental variable RASPI_IP will be used several more times during this guide. Run on your host machine to test ssh connection. export RASPI_IP = pi@192.168.8.170 ssh-copy-id -i ~/.ssh/id_rsa.pub $RASPI_IP ssh $RASPI_IP echo \"success\" # should echo success without prompting user to enter password","title":"Prepare Raspberry Pi"},{"location":"instrumentation/#kernel-compilation","text":"Prepare build environment. Ubuntu 20.04 LTS was used in this example. Install dependencies on your host machine and get source code. sudo apt install crossbuild-essential-armhf # default toolchain sudo apt install python-is-python3 # no python2 in ubuntu 20 fix sudo apt install bison flex sudo apt install qtbase5-dev pkg-config # xconfig sudo apt install libncurses5-dev # menuconfig cd git git clone --depth = 1 https://github.com/raspberrypi/linux cd linux # at the moment of writing we are using rpi-5.10.y branch specifically # 581049d718caf95f5feb00607ac748d5841cf27c commit git checkout 581049d718caf95f5feb00607ac748d5841cf27c Patch kernel For future debug output we add CONFIG_DYNAMIC_DEBUG=y to bcm2709_defconfig. The rest of this patch is the code instrumentation functions themself. instrument.patch Build kernel On your host machine: cd git cd linux export KERNEL = kernel7 # output build directories export BUILD_DIR = build export INSTALL_PATH = install_tmp # temp directory for new content of the /boot and /root partion export BOOT_PART_TMP = $BUILD_DIR / $INSTALL_PATH /boot # make modules_install will create build/install_tmp/root/lib directory during # install. we dont need to specify $BUILD_DIR prefix export ROOT_PART_TMP = $INSTALL_PATH /root # prepare output directory mkdir -p $BOOT_PART_TMP mkdir -p $BOOT_PART_TMP /overlays make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR bcm2709_defconfig make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR scripts prepare modules_prepare make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR zImage modules dtbs make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR modules_install INSTALL_MOD_PATH = $ROOT_PART_TMP # export K_VERSION variable export K_VERSION = $( make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- O = $BUILD_DIR -s kernelrelease ) cp $BUILD_DIR /arch/arm/boot/zImage $BOOT_PART_TMP / $KERNEL .img cp $BUILD_DIR /arch/arm/boot/dts/*.dtb $BOOT_PART_TMP cp $BUILD_DIR /arch/arm/boot/dts/overlays/*.dtb $BOOT_PART_TMP /overlays Deploy On your host machine: export PI_HOME = /home/pi cd ~/git/linux tar -zcvf install_pkg.tar.gz $BUILD_DIR / $INSTALL_PATH scp install_pkg.tar.gz $RASPI_IP :/home/pi/ ssh $RASPI_IP tar -xvzf $PI_HOME /install_pkg.tar.gz ssh $RASPI_IP rm $PI_HOME /install_pkg.tar.gz ssh $RASPI_IP sudo cp -r $PI_HOME /build/install_tmp/root/lib/* /lib ssh $RASPI_IP sudo cp -r $PI_HOME /build/install_tmp/boot/* /boot ssh $RASPI_IP rm -rf $PI_HOME /build ssh $RASPI_IP sudo reboot Test if dynamic debug option is enabled ssh $RASPI_IP sudo modprobe configs ssh $RASPI_IP \"zcat /proc/config.gz | grep DYNAMIC_DEBUG\" # you should get the following output: # CONFIG_DYNAMIC_DEBUG=y # CONFIG_DYNAMIC_DEBUG_CORE=y Build instrumented module cd ~/git/linux export BUILD_DIR = build export K_VERSION = $( make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- O = $BUILD_DIR -s kernelrelease ) make ARCH = arm CROSS_COMPILE = arm-linux-gnueabihf- -j4 O = $BUILD_DIR -C . M = drivers/char/tpm EXTRA_CFLAGS = \"-g -DDEBUG=1 -finstrument-functions\" export MOD_SRC = build/drivers/char/tpm export MOD_TMP_DST = /home/pi export MOD_DST = /lib/modules/ $K_VERSION /kernel/drivers/char/tpm scp $MOD_SRC /tpm.ko $RASPI_IP : $MOD_TMP_DST / scp $MOD_SRC /tpm_tis_core.ko $RASPI_IP : $MOD_TMP_DST scp $MOD_SRC /tpm_tis_spi.ko $RASPI_IP : $MOD_TMP_DST ssh $RASPI_IP sudo mv tpm.ko $MOD_DST ; ssh $RASPI_IP sudo mv tpm_tis_core.ko $MOD_DST ; ssh $RASPI_IP sudo mv tpm_tis_spi.ko $MOD_DST ; At this point, we need to enable device tree overlay for tpm. In Raspberry Pi ssh terminal: sudo nano /boot/config.txt # add at the bottom dtparam = spi = on dtoverlay = tpm-slb9670 # permanently enable debug log level sudo nano /boot/cmdline.txt add 'loglevel=7' at the end of the line # reboot raspi sudo reboot At this point, just after raspi reboot you should be able to see tpm function traces in dmesg . Example trace: In Raspberry Pi ssh terminal: $ dmesg | grep tpm_addr [ 9.358361] tpm_addr_enter: 0x7f0ee070 0x801022a4 [ 9.358546] tpm_addr_enter: 0x7f0ee000 0x7f0ee15c [ 9.359167] tpm_addr_exit: 0x7f0ee000 0x7f0ee15c [ 9.359180] tpm_addr_exit: 0x7f0ee070 0x801022a4 [ 9.420744] tpm_addr_enter: 0x7f09f000 0x801022a4","title":"Kernel compilation"},{"location":"instrumentation/#collect-traces-and-get-function-names-from-addresses","text":"Last step to get execution traces is to use provided scripts located in ms-tpm-20-ref/Samples/Nucleo-TPM/scripts/kfunc_tracer Pull logs from your host machine: $ ./pull_logs.sh RASPI_IP: pi@192.168.8.170 creating ./logs directory entering ./logs directory cleaning ./logs directory collecting dmesg tpm_addr logs collecting tpm related /proc/modules entries Get function names. Below you can see the full call stack of tpm module failing due to not connected hardware of tpm module. To be executed on your host machine. $ python get_call_stack.py tpm_tis_spi.ko: tpm_tis_spi_driver_probe() tpm_tis_spi.ko: tpm_tis_spi_probe() tpm_tis_spi.ko: tpm_tis_spi_init() tpm_tis_core.ko: tpm_tis_core_init() tpm.ko: tpmm_chip_alloc() tpm.ko: tpm_chip_alloc() tpm.ko: tpm2_init_space() tpm.ko: tpm2_init_space() tpm.ko: tpm_chip_alloc() tpm.ko: tpmm_chip_alloc() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: wait_startup() tpm_tis_spi.ko: tpm_tis_spi_read_bytes() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_read_bytes() tpm_tis_core.ko: wait_startup() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_remove() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_spi.ko: tpm_tis_spi_read32() tpm_tis_spi.ko: tpm_tis_spi_read_bytes() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_read_bytes() tpm_tis_spi.ko: tpm_tis_spi_read32() tpm_tis_spi.ko: tpm_tis_spi_write32() tpm_tis_spi.ko: tpm_tis_spi_write_bytes() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_flow_control() tpm_tis_spi.ko: tpm_tis_spi_transfer() tpm_tis_spi.ko: tpm_tis_spi_write_bytes() tpm_tis_spi.ko: tpm_tis_spi_write32() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_clkrun_enable() tpm_tis_core.ko: tpm_tis_remove() tpm_tis_core.ko: tpm_tis_core_init() tpm_tis_spi.ko: tpm_tis_spi_init() tpm_tis_spi.ko: tpm_tis_spi_probe() tpm_tis_spi.ko: tpm_tis_spi_driver_probe() tpm.ko: tpm_dev_release() tpm.ko: tpm_dev_release()","title":"Collect traces and get function names from addresses"},{"location":"instrumentation/#whole-logs-from-the-test-procedure","text":"Below we have collected call stack for Raspberry Pi TPM driver startup. Log file with TPM module plugged in Log file without TPM","title":"Whole logs from the test procedure"},{"location":"issues/","text":"Current issues tpm2-tools incompatibility with tty devices tpm2-tools are not compatible with the current tpm implementation, which uses USB CDC, /dev/tty* device as a communication interface. This issue is probably caused, by the lack of poll function implementation is tty kernel driver. Apparently, tpm_tools expects a slightly different behavior and are designed to work with a particular tpm driver The actual line of code in tpm-tss library, causing failures in communication. https://github.com/tpm2-software/tpm2-tss/blob/master/src/tss2-tcti/tcti-device.c#L466 Scripts are provided to make it easier to debug and investigate the behavior both for tpm2-tools and tpm2-tss tpm2-pytss libraries. simulator - virtual serial port was created to act as a simulated tpm device, to capture commands, that tpm2-tools are sending. Those commands can be directly used, using lpntpn_cmd script. tpm2-pytss_example - simple startup example using tpm2-pytss library tpm2-tts_example - simple startup example using tpm2-tss library - has to be compiled with provided Makefile Some additional information could be found in Scripts readme file Investigate possible security issues As Jeremy Boone mention @ slack trusted-computing channel , we should investigate possible flaws in NVMem implementation. the _plat__ APIs in NVMem.c are where i\u2019ve seen the most mistakes. If you are persisting data to external flash then you need confidentiality, integrity, rollback-protection, and replay-protection. Incoming data reception and decoding Data sent from VCOM application always get received as full command located in one incoming buffer. Parsing commands make use of this feature, letting the application execute only commands, that are received at once. static int8_t CDC_Receive_FS ( uint8_t * Buf , uint32_t * Len ) { /* USER CODE BEGIN 6 */ if ( ! TpmSignalEvent ( Buf , Len )) { return ( USBD_FAIL ); } ... } Protocol analysis - early conclusions Getting STM32 to communicate with VCOM application leads us to a current yet not resolved problem. Right now we are able to execute commands on TPM, but an error occurs when the host device verifies the response data. Specifically, this line of code causes an error: * (( unsigned int * ) & response [ sizeof ( unsigned short ) + sizeof ( unsigned int )]) == 0 VCOM-TPM.cpp:198 For now, it's not clear what the response data of TPM_Startup command should look like and what each byte of command represents. Command and response data looks as follows. unsigned char CmdBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0c , 0x00 , 0x00 , 0x01 , 0x44 , 0x00 , 0x00 }; unsigned char RspBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0a , 0x00 , 0x00 , 0x00 , 0x00 }; This data is output via ITM trace on port 2. Correctness of data was verified on both sides of the communication. Startup command data is hardcoded in VCOM application here what makes it hard to reason about its origins. Raw data dumped from CDC_Receive_FS shows some similarities between VCOM sent command and test run of tpm2_startup -T device:/dev/ttyACM1 application. VCOM Startup command received 0x54 0x70 0x6d 0x32 0x3 0x0 0x0 0x0 0x4 0x0 0x0 0x0 0xac 0x44 0x69 0x61 0x54 0x70 0x6d 0x32 0x6 0x0 0x0 0x0 0x14 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0xc 0x0 0x0 0x0 0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x0 tpm2_startup received command 0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x1 As you can see VCOM sends much more bytes. Presumably two commands (?) as new the line gets appended to the log after a new pack of data gets received by CDC_Receive_FS function. static int8_t CDC_Receive_FS ( uint8_t * Buf , uint32_t * Len ) { for ( int i = 0 ; i <* Len ; i ++ ) { itmPrintAppend ( ITMSTDERR , \"0x%x \" , Buf [ i ]); } itmPrintAppend ( ITMSTDERR , \" \\n \" ); ... } What's interesting is the last 12 bytes of the received buffer, which differs only in the last byte between VCOM and tpm2_startup. Software simulator tpm-js shows exactly the same command and response data, as ITM debug output when using VCOM application. tpm-js output: PowerOn ManufactureReset Startup About to execute command TPM2_CC_Startup Command buffer (12): 0000 80 01 00 00 00 0c 00 00 01 44 00 00 .........D.. Response buffer (10): 0000 80 01 00 00 00 0a 00 00 00 00 .......... ITM port 2 output: //2021.10.14-08:52:37.000GMT unsigned char CmdBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0c , 0x00 , 0x00 , 0x01 , 0x44 , 0x00 , 0x00 }; //2021.10.14-08:52:37.330GMT unsigned char RspBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0a , 0x00 , 0x00 , 0x00 , 0x00 }; From what I discovered, the first 4 bytes of VCOM communication are the magic signal values from TpmDevice.h 0x54 0x70 0x6d 0x32 #define SIGNALMAGIC (0x326d7054) //Tpm2 For now, the rest of the protocol is to be discovered. Probably we should focus on getting tpm2_tools to work with STM32, as we probably don't want to port VCOM to Linux. This requires a better understanding of the communication protocol itself thus the following document will be helpful: TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification Section 1.3 Refedences TCG PC Client Platform TPM Profile (PTP) Specification Chapter 6 TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification 20.10.2021 update: The incoming data sent from VCOM application decodes as follows: 54 70 6d 32 6 0 0 0 14 0 0 0 0 0 0 0 c 0 0 0 80 1 0 0 0 c 0 0 1 44 0 0 sizeof ( signalWrapper_t ) { sig -> s . magic '\\ x54 \\ x70 \\ x6d \\ x32 ' uint32_t hardcoded magic value sig -> s . signal '\\ x06 \\ x00 \\ x00 \\ x00 ' uint32_t signal enum sig -> s . dataSize '\\ x14 \\ x00 \\ x00 \\ x00 ' uint32_t data size } sizeof ( unsigned int ) * 2 ) { '\\ x00 \\ x00 \\ x00 \\ x00 ' uint32_t locality '\\ x0c \\ x00 \\ x00 \\ x00 ' uint32_t cmdSize } actual TPM command Global . h : 1098 '\\ x80 \\ x01 ' TPM_ST command . tag ; '\\ x00 \\ x00 '\\ x00 \\ x0c ' UINT32 commandSize ; '\\ x00 \\ x00 \\ x01 \\ x44 ' TPM_CC command . code '\\ x00 \\ x00 ' Probably all of those header values are redundant and should be decoded using unmarshal mechanism. Memory usage Memory limitations hit us right at the beginning preventing us from building the project for STM32L476RG on both Linux STM32CubeIDE and Windows Atollic Studio. After limiting the minimal stack size in the linker script the application fits in SRAM memory, but probably the problem will hit us soon after successful execution of TPM command. At the moment of writing, we are almost out of memory. Outdated repository After struggling a lot with build errors while compiling the master branch we decided to roll back the repo. Chosen commit is the one, that adds STM32 samples. Plans involve updating the repo, eventually hitting most actual changes. Differences between STM32 and Simulator implementation of command parsing Dealing with the actual communication with TPM core we are facing some minor problems. VCOM application dedicated to TPM communication, located in ms-tpm-20-ref/Samples/Nucleo-TPM/VCOM is created using Windows, so we have to decide if we want to port it. Data packet for controlling the TPM differs between one used by tpm2_tools , Simulator, and STM32 implementation. This point needs additional investigation, but a quick glance at received data sent by using tpm2_startup -T device -d/dev/ttyACM1 --state command ensures us about it. By /dev/ACM1 port we mean STM32 USB CDC. Possible bug in build system According to the project assumptions, whole configuration is done using user_settings.h file. Previously encountered error led us to the conclusion that some parts of the aplication could be misconfigured. Some of the build switches inside TpmBuildSwitches.h could be enabled in an unwanted way. It needs to be further investigated with defines like SIMULATION and SELF_TESTS in mind. Maybe we can get some extra free RAM space this way.","title":"Current issues"},{"location":"issues/#current-issues","text":"","title":"Current issues"},{"location":"issues/#tpm2-tools-incompatibility-with-tty-devices","text":"tpm2-tools are not compatible with the current tpm implementation, which uses USB CDC, /dev/tty* device as a communication interface. This issue is probably caused, by the lack of poll function implementation is tty kernel driver. Apparently, tpm_tools expects a slightly different behavior and are designed to work with a particular tpm driver The actual line of code in tpm-tss library, causing failures in communication. https://github.com/tpm2-software/tpm2-tss/blob/master/src/tss2-tcti/tcti-device.c#L466 Scripts are provided to make it easier to debug and investigate the behavior both for tpm2-tools and tpm2-tss tpm2-pytss libraries. simulator - virtual serial port was created to act as a simulated tpm device, to capture commands, that tpm2-tools are sending. Those commands can be directly used, using lpntpn_cmd script. tpm2-pytss_example - simple startup example using tpm2-pytss library tpm2-tts_example - simple startup example using tpm2-tss library - has to be compiled with provided Makefile Some additional information could be found in Scripts readme file","title":"tpm2-tools incompatibility with tty devices"},{"location":"issues/#investigate-possible-security-issues","text":"As Jeremy Boone mention @ slack trusted-computing channel , we should investigate possible flaws in NVMem implementation. the _plat__ APIs in NVMem.c are where i\u2019ve seen the most mistakes. If you are persisting data to external flash then you need confidentiality, integrity, rollback-protection, and replay-protection.","title":"Investigate possible security issues"},{"location":"issues/#incoming-data-reception-and-decoding","text":"Data sent from VCOM application always get received as full command located in one incoming buffer. Parsing commands make use of this feature, letting the application execute only commands, that are received at once. static int8_t CDC_Receive_FS ( uint8_t * Buf , uint32_t * Len ) { /* USER CODE BEGIN 6 */ if ( ! TpmSignalEvent ( Buf , Len )) { return ( USBD_FAIL ); } ... }","title":"Incoming data reception and decoding"},{"location":"issues/#protocol-analysis-early-conclusions","text":"Getting STM32 to communicate with VCOM application leads us to a current yet not resolved problem. Right now we are able to execute commands on TPM, but an error occurs when the host device verifies the response data. Specifically, this line of code causes an error: * (( unsigned int * ) & response [ sizeof ( unsigned short ) + sizeof ( unsigned int )]) == 0 VCOM-TPM.cpp:198 For now, it's not clear what the response data of TPM_Startup command should look like and what each byte of command represents. Command and response data looks as follows. unsigned char CmdBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0c , 0x00 , 0x00 , 0x01 , 0x44 , 0x00 , 0x00 }; unsigned char RspBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0a , 0x00 , 0x00 , 0x00 , 0x00 }; This data is output via ITM trace on port 2. Correctness of data was verified on both sides of the communication. Startup command data is hardcoded in VCOM application here what makes it hard to reason about its origins. Raw data dumped from CDC_Receive_FS shows some similarities between VCOM sent command and test run of tpm2_startup -T device:/dev/ttyACM1 application. VCOM Startup command received 0x54 0x70 0x6d 0x32 0x3 0x0 0x0 0x0 0x4 0x0 0x0 0x0 0xac 0x44 0x69 0x61 0x54 0x70 0x6d 0x32 0x6 0x0 0x0 0x0 0x14 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0xc 0x0 0x0 0x0 0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x0 tpm2_startup received command 0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x1 As you can see VCOM sends much more bytes. Presumably two commands (?) as new the line gets appended to the log after a new pack of data gets received by CDC_Receive_FS function. static int8_t CDC_Receive_FS ( uint8_t * Buf , uint32_t * Len ) { for ( int i = 0 ; i <* Len ; i ++ ) { itmPrintAppend ( ITMSTDERR , \"0x%x \" , Buf [ i ]); } itmPrintAppend ( ITMSTDERR , \" \\n \" ); ... } What's interesting is the last 12 bytes of the received buffer, which differs only in the last byte between VCOM and tpm2_startup. Software simulator tpm-js shows exactly the same command and response data, as ITM debug output when using VCOM application. tpm-js output: PowerOn ManufactureReset Startup About to execute command TPM2_CC_Startup Command buffer (12): 0000 80 01 00 00 00 0c 00 00 01 44 00 00 .........D.. Response buffer (10): 0000 80 01 00 00 00 0a 00 00 00 00 .......... ITM port 2 output: //2021.10.14-08:52:37.000GMT unsigned char CmdBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0c , 0x00 , 0x00 , 0x01 , 0x44 , 0x00 , 0x00 }; //2021.10.14-08:52:37.330GMT unsigned char RspBuf [ 12 ] = { 0x80 , 0x01 , 0x00 , 0x00 , 0x00 , 0x0a , 0x00 , 0x00 , 0x00 , 0x00 }; From what I discovered, the first 4 bytes of VCOM communication are the magic signal values from TpmDevice.h 0x54 0x70 0x6d 0x32 #define SIGNALMAGIC (0x326d7054) //Tpm2 For now, the rest of the protocol is to be discovered. Probably we should focus on getting tpm2_tools to work with STM32, as we probably don't want to port VCOM to Linux. This requires a better understanding of the communication protocol itself thus the following document will be helpful: TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification Section 1.3 Refedences TCG PC Client Platform TPM Profile (PTP) Specification Chapter 6 TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification 20.10.2021 update: The incoming data sent from VCOM application decodes as follows: 54 70 6d 32 6 0 0 0 14 0 0 0 0 0 0 0 c 0 0 0 80 1 0 0 0 c 0 0 1 44 0 0 sizeof ( signalWrapper_t ) { sig -> s . magic '\\ x54 \\ x70 \\ x6d \\ x32 ' uint32_t hardcoded magic value sig -> s . signal '\\ x06 \\ x00 \\ x00 \\ x00 ' uint32_t signal enum sig -> s . dataSize '\\ x14 \\ x00 \\ x00 \\ x00 ' uint32_t data size } sizeof ( unsigned int ) * 2 ) { '\\ x00 \\ x00 \\ x00 \\ x00 ' uint32_t locality '\\ x0c \\ x00 \\ x00 \\ x00 ' uint32_t cmdSize } actual TPM command Global . h : 1098 '\\ x80 \\ x01 ' TPM_ST command . tag ; '\\ x00 \\ x00 '\\ x00 \\ x0c ' UINT32 commandSize ; '\\ x00 \\ x00 \\ x01 \\ x44 ' TPM_CC command . code '\\ x00 \\ x00 ' Probably all of those header values are redundant and should be decoded using unmarshal mechanism.","title":"Protocol analysis - early conclusions"},{"location":"issues/#memory-usage","text":"Memory limitations hit us right at the beginning preventing us from building the project for STM32L476RG on both Linux STM32CubeIDE and Windows Atollic Studio. After limiting the minimal stack size in the linker script the application fits in SRAM memory, but probably the problem will hit us soon after successful execution of TPM command. At the moment of writing, we are almost out of memory.","title":"Memory usage"},{"location":"issues/#outdated-repository","text":"After struggling a lot with build errors while compiling the master branch we decided to roll back the repo. Chosen commit is the one, that adds STM32 samples. Plans involve updating the repo, eventually hitting most actual changes.","title":"Outdated repository"},{"location":"issues/#differences-between-stm32-and-simulator-implementation-of-command-parsing","text":"Dealing with the actual communication with TPM core we are facing some minor problems. VCOM application dedicated to TPM communication, located in ms-tpm-20-ref/Samples/Nucleo-TPM/VCOM is created using Windows, so we have to decide if we want to port it. Data packet for controlling the TPM differs between one used by tpm2_tools , Simulator, and STM32 implementation. This point needs additional investigation, but a quick glance at received data sent by using tpm2_startup -T device -d/dev/ttyACM1 --state command ensures us about it. By /dev/ACM1 port we mean STM32 USB CDC.","title":"Differences between STM32 and Simulator implementation of command parsing"},{"location":"issues/#possible-bug-in-build-system","text":"According to the project assumptions, whole configuration is done using user_settings.h file. Previously encountered error led us to the conclusion that some parts of the aplication could be misconfigured. Some of the build switches inside TpmBuildSwitches.h could be enabled in an unwanted way. It needs to be further investigated with defines like SIMULATION and SELF_TESTS in mind. Maybe we can get some extra free RAM space this way.","title":"Possible bug in build system"},{"location":"journal/","text":"Journal 04-08.10.2021 Fixing compilation problems. Converting project to STM32CubeIDE. Setup ITM trace logging. 11-15.10.2021 Getting USB CDC work. Experiments with tpm2-tools. Writing documentation. Investigation of memory usage and choosing best suited hw platform. 14.10.2021 Building and running VCOM project Samples/Nucleo-TPM/VCOM (Visual Studio 2017). First successful communication with TPM core. Investigation the root cause of response check failing. link 15.10.2021 Small fix for NDEBUG enabled compilation. Protocol analysis. 18.10.2021 Protocol analysis. 19.10.2021 Protocol analysis Decoding command and response data frames. Setting up lib tpm2-tss and tpm2-pytss for future communication. 20/21.10.2021 Protocol analysis. Investigation of lib tpm2-tss and tpm2-pytss behavior and wrong packet reception. 26.10.2021 USB communication reworked, added circular buffer and functions responsible for command validation. Development of python scripts responsible for serial communication and investigation the root cause of tpm2_tool @ /dev/ACM* failures. 27.10.2021 Cleanup and refactor of python scripts. Writing documentation. 28.10.2021 Kernel development setup. Browsing tpm related kernel code. 02.11.2021 Writing docs. Function profiler prototype refactor. Experimenting with tpm module debug build. 03.11.2021 Investigation of dynamic debug behavior. Writing how-to for kernel module recompilation. 04.11.2021 - Writing how-to for kernel instrumentation. https://github.com/lpn-plant/lpntpm-docs/pull/7 05-09.11.2021 - Raspberry Pi / STM32 SPI communication. - TPM SPI specification research. 12.11.2021 - TPM SPI specification research. 22.11.2021 - Hardware interfaces requirements - documentation. https://github.com/lpn-plant/lpntpm-docs/pull/6/files 10.11.2021 Raspberry Pi demonstration with TPM module","title":"Journal"},{"location":"journal/#journal","text":"04-08.10.2021 Fixing compilation problems. Converting project to STM32CubeIDE. Setup ITM trace logging. 11-15.10.2021 Getting USB CDC work. Experiments with tpm2-tools. Writing documentation. Investigation of memory usage and choosing best suited hw platform. 14.10.2021 Building and running VCOM project Samples/Nucleo-TPM/VCOM (Visual Studio 2017). First successful communication with TPM core. Investigation the root cause of response check failing. link 15.10.2021 Small fix for NDEBUG enabled compilation. Protocol analysis. 18.10.2021 Protocol analysis. 19.10.2021 Protocol analysis Decoding command and response data frames. Setting up lib tpm2-tss and tpm2-pytss for future communication. 20/21.10.2021 Protocol analysis. Investigation of lib tpm2-tss and tpm2-pytss behavior and wrong packet reception. 26.10.2021 USB communication reworked, added circular buffer and functions responsible for command validation. Development of python scripts responsible for serial communication and investigation the root cause of tpm2_tool @ /dev/ACM* failures. 27.10.2021 Cleanup and refactor of python scripts. Writing documentation. 28.10.2021 Kernel development setup. Browsing tpm related kernel code. 02.11.2021 Writing docs. Function profiler prototype refactor. Experimenting with tpm module debug build. 03.11.2021 Investigation of dynamic debug behavior. Writing how-to for kernel module recompilation. 04.11.2021 - Writing how-to for kernel instrumentation. https://github.com/lpn-plant/lpntpm-docs/pull/7 05-09.11.2021 - Raspberry Pi / STM32 SPI communication. - TPM SPI specification research. 12.11.2021 - TPM SPI specification research. 22.11.2021 - Hardware interfaces requirements - documentation. https://github.com/lpn-plant/lpntpm-docs/pull/6/files 10.11.2021 Raspberry Pi demonstration with TPM module","title":"Journal"},{"location":"rpi/","text":"This chapter shows the TPM test procedure using the Raspberry Pi 3 module Lets Trust TPM Information 1. Product contents LetsTrust TPM Module (12.7 x 17.5 mm) Female header (2x8 pin) 2. Install LetsTrust TPM module Installation precedure : First, insert the additional female header starting with pin 1 (on the far left side) into the Raspberry Pi GPIO header. The supplied female header helps to plug in the TPM module in the right position. After mounting it, could be removed. Insert the Letstrust TPM module directly next to the additional female header. The TPM module will be installed starting with pin 17 , facing downwards with the chip and oriented towards the HDMI port. The LetsTrust TPM module is also compatible with other Raspberry Pi modules. All connections should be done while the power supply is switched OFF! 3. Usage examples The best projects for the TPM module come from the community in which the Letstrust supplied the hardware. Already, several core software packages are available: Link Description http://github.com/tpm2-software Tools to use the TPM https://github.com/Infineon/eltt2 ELTT2 Infineon Embedded Linux TPM Toolbox 2 for TPM 2.0 - test, diagnostics and essential changing of the Infineon TPM chip p https://github.com/PaulKissinger/LetsTrust Useful resources and script to get you started with the TPM and compilation/installation of the TPM 2.0 Tools. Application samples, documentation, and a lot of additional information from the community are available at www.letsTrust.de . To report your examples and develop applications send an e-mail at support@pi3g.com or info@letstrust.de . First, install the tpm2-tools sudo apt install tpm2_tools After that you could run all the tools which are described at: tpm2-tools /man/ For example: Example 1: sudo tpm2_pcrread Example 2: sudo tpm2_getcap -l Example 3: sudo readclock","title":"Running TPM 2.0 module on Raspberry Pi"},{"location":"rpi/#this-chapter-shows-the-tpm-test-procedure-using-the-raspberry-pi-3-module","text":"","title":"This chapter shows the TPM test procedure using the Raspberry Pi 3 module"},{"location":"rpi/#lets-trust-tpm-information","text":"","title":"Lets Trust TPM Information"},{"location":"rpi/#1-product-contents","text":"LetsTrust TPM Module (12.7 x 17.5 mm) Female header (2x8 pin)","title":"1. Product contents"},{"location":"rpi/#2-install-letstrust-tpm-module","text":"Installation precedure : First, insert the additional female header starting with pin 1 (on the far left side) into the Raspberry Pi GPIO header. The supplied female header helps to plug in the TPM module in the right position. After mounting it, could be removed. Insert the Letstrust TPM module directly next to the additional female header. The TPM module will be installed starting with pin 17 , facing downwards with the chip and oriented towards the HDMI port. The LetsTrust TPM module is also compatible with other Raspberry Pi modules. All connections should be done while the power supply is switched OFF!","title":"2. Install LetsTrust TPM module"},{"location":"rpi/#3-usage-examples","text":"The best projects for the TPM module come from the community in which the Letstrust supplied the hardware. Already, several core software packages are available: Link Description http://github.com/tpm2-software Tools to use the TPM https://github.com/Infineon/eltt2 ELTT2 Infineon Embedded Linux TPM Toolbox 2 for TPM 2.0 - test, diagnostics and essential changing of the Infineon TPM chip p https://github.com/PaulKissinger/LetsTrust Useful resources and script to get you started with the TPM and compilation/installation of the TPM 2.0 Tools. Application samples, documentation, and a lot of additional information from the community are available at www.letsTrust.de . To report your examples and develop applications send an e-mail at support@pi3g.com or info@letstrust.de .","title":"3. Usage examples"},{"location":"rpi/#first-install-the-tpm2-tools","text":"sudo apt install tpm2_tools After that you could run all the tools which are described at: tpm2-tools /man/ For example: Example 1: sudo tpm2_pcrread Example 2: sudo tpm2_getcap -l Example 3: sudo readclock","title":"First, install the tpm2-tools"},{"location":"rpi_connection/","text":"Connecting Raspberry Pi 3 with Windows OS using USB/UART converter For make this task necessary are: Raspberry Pi 3 Model B USB/UART Converter TPM module PC with Windows OS Guide The first step is Raspberry Pi OS installation using Imager program. Please choose: Download for Windows Please download the OS: RPI OS Connect the SD card reader to the USB port and run the file flashing procedure via Imager software. Find and edit config.txt file. Please make sure that after edit you have one more additional line as the line below: enable_uart=1 Recommended is to add the above line at the bottom of the config.txt file. After that plug uSD card into the Raspberry Pi socket. Make sure that your converter has the right voltage support! 3.3V is recommended! Connect the USB/UART converter to the USB port at your PC. Run PuTTY . Set the parameters as below. Important is to choose the serial option, the right COM port and speed.* After that open the serial port and plug the power supply into your RPi. Now you will work in the terminal. Log into Raspberry Pi. The default login is: pi and password: raspberry . Configuration and activation under Raspbian The LetsTrust TPM module is supported directly by Linux, starting with Kernel 4.14.85. Please refer to www.letsTrust.de for further information. Update to the latest Raspbian Stretch and active the TPM as /dev/tpm0 using the following commands: $ sudo apt-get update && sudo apt-get upgrade $ sudo nano /boot/config.txt Necessary is to add these two lines at the bottom of the document: dtparam=spi=on dtoverlay=tpm-slb9670 $ sudo reboot To make sure that the initialization process was successful please check if you have available: /dev/tpm0","title":"Connecting Raspberry Pi with Windows OS"},{"location":"rpi_connection/#connecting-raspberry-pi-3-with-windows-os-using-usbuart-converter","text":"For make this task necessary are: Raspberry Pi 3 Model B USB/UART Converter TPM module PC with Windows OS","title":"Connecting Raspberry Pi 3 with Windows OS using USB/UART converter"},{"location":"rpi_connection/#guide","text":"The first step is Raspberry Pi OS installation using Imager program. Please choose: Download for Windows Please download the OS: RPI OS Connect the SD card reader to the USB port and run the file flashing procedure via Imager software. Find and edit config.txt file. Please make sure that after edit you have one more additional line as the line below: enable_uart=1 Recommended is to add the above line at the bottom of the config.txt file. After that plug uSD card into the Raspberry Pi socket. Make sure that your converter has the right voltage support! 3.3V is recommended! Connect the USB/UART converter to the USB port at your PC. Run PuTTY . Set the parameters as below. Important is to choose the serial option, the right COM port and speed.* After that open the serial port and plug the power supply into your RPi. Now you will work in the terminal. Log into Raspberry Pi. The default login is: pi and password: raspberry .","title":"Guide"},{"location":"rpi_connection/#configuration-and-activation-under-raspbian","text":"The LetsTrust TPM module is supported directly by Linux, starting with Kernel 4.14.85. Please refer to www.letsTrust.de for further information. Update to the latest Raspbian Stretch and active the TPM as /dev/tpm0 using the following commands: $ sudo apt-get update && sudo apt-get upgrade $ sudo nano /boot/config.txt Necessary is to add these two lines at the bottom of the document: dtparam=spi=on dtoverlay=tpm-slb9670 $ sudo reboot To make sure that the initialization process was successful please check if you have available: /dev/tpm0","title":"Configuration and activation under Raspbian"},{"location":"rpi_faq/","text":"FAQ & Good to know Which chip does the TPM use? Let's Trust TPM module https://www.pi3g.com use the Infineon OPTIGA SLB 9670 TPM 2.0 Firmware 7.85 or later. This chip is compliant with the TCG TPM 2.0 Specification, revision 1.38. Starting with Firmware Version 7.85 the SLB 9670 is certified with Common Criteria EAL4+ and FIPS 140-2. Can SPI still be used? Yes, CS0 can still be used, the TPM module uses CS1 . It is possible to address the TPM module using CS0 , by satisfying both conditions: moving the 0-Ohm resistor from position R3 to R2, patching the device tree overlay to talk to the module on CS0. The component placing can be found at: https://www.letstrust.de/uploads/letstrust-v2.0.placement.pdf Can I download a circuit diagram? The circuit diagram is available at: https://www.letstrust.de/uploads/letstrust-v2.0schematic.pdf How do I get support? Many topics could be found at https://www.letsTrust.de For more information in-depth questions, please get in touch with support: suport@pi3g.com Can you supply a custom version of the TPM module? Starting at just 100 modules Trust TPM can modify the design for special requests. More information at: suport@pi3g.com","title":"FAQ"},{"location":"rpi_faq/#faq-good-to-know","text":"","title":"FAQ &amp; Good to know"},{"location":"rpi_faq/#which-chip-does-the-tpm-use","text":"Let's Trust TPM module https://www.pi3g.com use the Infineon OPTIGA SLB 9670 TPM 2.0 Firmware 7.85 or later. This chip is compliant with the TCG TPM 2.0 Specification, revision 1.38. Starting with Firmware Version 7.85 the SLB 9670 is certified with Common Criteria EAL4+ and FIPS 140-2.","title":"Which chip does the TPM use?"},{"location":"rpi_faq/#can-spi-still-be-used","text":"Yes, CS0 can still be used, the TPM module uses CS1 . It is possible to address the TPM module using CS0 , by satisfying both conditions: moving the 0-Ohm resistor from position R3 to R2, patching the device tree overlay to talk to the module on CS0. The component placing can be found at: https://www.letstrust.de/uploads/letstrust-v2.0.placement.pdf","title":"Can SPI still be used?"},{"location":"rpi_faq/#can-i-download-a-circuit-diagram","text":"The circuit diagram is available at: https://www.letstrust.de/uploads/letstrust-v2.0schematic.pdf","title":"Can I download a circuit diagram?"},{"location":"rpi_faq/#how-do-i-get-support","text":"Many topics could be found at https://www.letsTrust.de For more information in-depth questions, please get in touch with support: suport@pi3g.com","title":"How do I get support?"},{"location":"rpi_faq/#can-you-supply-a-custom-version-of-the-tpm-module","text":"Starting at just 100 modules Trust TPM can modify the design for special requests. More information at: suport@pi3g.com","title":"Can you supply a custom version of the TPM module?"},{"location":"running/","text":"Running The project is using three communication interfaces to debug and talk to TPM core. TPM core communication is handled by STM32 USB CDC interface. See https://github.com/microsoft/ms-tpm-20-ref/blob/master/Samples/Nucleo-TPM/USB_Hookup.jpg printf is forwarded to the integrated STLink VCOM. fprintf(stderr, *) could be received on port 0 of ITM SWV. dbgPrint uses port 1 of ITM SWV. ITM trace configuration For now, ITM trace output is available only through STM32CubeIDE. We are planning to add this feature using command-line tools like openocd or STM32_Programmer_CLI . To view ITM output first you should enable SWV ITM console, by selecting it in Window -> Show View -> Other . Next thing is to start to debug the application and when it hits the first breakpoint select Configure trace under SWV ITM console. Select the first three channels and accept. After that you should be ready to go, so just click Start Trace - red dot icon and hit F8 to continue program execution. Now you should see trace debug output like in the picture below. USB CDC configuration On some platforms (Ubuntu in my case) '/dev/ttyACM*' ports automatically receive AT commands just after plugging USB cable. As we are using raw data format to communicate with TPM device and STM32 CDC port mount as /dev/ACM* device this could be problematic. To stop receiving AT commands just disable ModemManager service with the following command: systemctl stop ModemManager sudo systemctl disable ModemManager Sample command execution As being said, the communication to the TPM core is done using Nucleo's USB CDC Port. In the original implementation VCOM - Windows application was created for this purpose. We choose a different approach and provide several ways to talk to a TPM. Host applications and scripts for experimenting with the protocol are located in ms-tpm-20-ref/Samples/Nucleo-TPM/scripts directory. scripts | lpntpn_cmd - main python script for tpm communication | see ./lpntpn_cmd --help for more info | README.md | simulator - serial port simulator for future protocol | and tpm2-tools/tpm2-tss anallisis | | tpm2-pytss_example - simple startup example using tpm2-pytss library | \u2514\u2500\u2500\u2500tpm2-tts_example - simple startup example using tpm2-tss library | \u2514\u2500\u2500\u2500utils For now only lpntpn_cmd is able to execute its full commands without any errors. pytss and tss examples were created for future communication with tpm device and right now are failing, probably due to not implemented pool functionality in tty kernel driver. More on that on Current issues page. At the moment of writing, only startup and shutdown commands were implemented. As the original implementation adds some redundant data to the protocol, --legacy | --no-legacy arguments were added to lpntpn_cmd application, to allow the user to send VCOM compatible legacy commands. Reception of such legacy commands requires commenting out #define NEW_SIGNAL_HANDLING macro in main.c file, as it is defined by default. Otherwise simple call to ./lpntpn_cmd should be enough to be able to execute startup command on lpntpn. Before running host-side applications, you should flash and start STM32 binary, with debug prints reception enabled with ITM ports 0,1,2 as mentioned in ITM trace configuration Succesfull execution, should result in the following console output: $ ./lpntpn_cmd running in non legacy mode... on /dev/ttyACM1 serial port... executing startup command... sending: b'\\x80\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x01D\\x00\\x00' waiting for response... received: bytearray(b'\\x80\\x01\\x00\\x00\\x00\\n\\x00\\x00\\x01\\x00') And following output in SWV ITM Data window ITM port 0: ========================= = Nucleo-L476RG TPM 2.0 = ========================= 2000.01.02-10:10:40.441GMT: Generated tpmUnique 875fcea802b97786efd69cb3c1f1371b 70d465d97b8c52532c3ba603f2fa571b ef6c44634a2910b303ef92a5d05a59f8 adbc978cca2f2f9874b4e5a2216c10ec 2000.01.02-10:10:40.573GMT: NVFile loaded (16kb, 2000.01.01-03:23:25GMT created, 84 writes, 2000.01.02-10:02:27GMT last) 2000.01.02-10:10:40.576GMT: _plat__SetNvAvail(). 2000.01.02-10:10:40.576GMT: _plat__Signal_PowerOn(). 2000.01.02-10:10:40.576GMT: _plat__Signal_Reset(). 2000.01.02-10:10:40.711GMT: NVFile loaded (16kb, 2000.01.01-03:23:25GMT created, 84 writes, 2000.01.02-10:02:27GMT last) 2000.01.02-10:10:40.714GMT: CDC_SET_LINE_CODING: 9600-8N1 2000.01.02-10:10:51.507GMT: CDC_SET_CONTROL_LINE_STATE: RTS=1, DTR=1 2000.01.02-10:10:51.507GMT: CDC_SET_LINE_CODING: 115200-7N2 2000.01.02-10:10:51.723GMT: Executing command TPM_CC_Startup() 2000.01.02-10:10:52.306GMT: NVFile written (16kb, 2000.01.01-03:23:25GMT created, 85 writes, 2000.01.02-10:10:52GMT last) 2000.01.02-10:10:52.309GMT: Completion time 0'1\" with ReturnCode {TPM_RC_SUCCESS} 2000.01.02-10:10:52.315GMT: CDC_SET_CONTROL_LINE_STATE: RTS=0, DTR=0 ITM port 1: 2000.01.02-10:10:51.723GMT: SignalCommand(12) 2000.01.02-10:10:52.309GMT: Response(10) ITM port 2: //2000.01.02-10:10:51.723GMT unsigned char CmdBuf[12] = { 0x80, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00 }; //2000.01.02-10:10:52.309GMT unsigned char RspBuf[10] = { 0x80, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00 }; An example, changing command type, serial port, and enabling legacy mode. ./lpntpn_cmd --port /dev/ttyACM0 --command shutdown --legacy running in legacy mode... on /dev/ttyACM0 serial port... executing shutdown command... sending: b'Tpm2\\x06\\x00\\x00\\x00\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x80\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x01E\\x00\\x00' waiting for response...","title":"Running"},{"location":"running/#running","text":"The project is using three communication interfaces to debug and talk to TPM core. TPM core communication is handled by STM32 USB CDC interface. See https://github.com/microsoft/ms-tpm-20-ref/blob/master/Samples/Nucleo-TPM/USB_Hookup.jpg printf is forwarded to the integrated STLink VCOM. fprintf(stderr, *) could be received on port 0 of ITM SWV. dbgPrint uses port 1 of ITM SWV.","title":"Running"},{"location":"running/#itm-trace-configuration","text":"For now, ITM trace output is available only through STM32CubeIDE. We are planning to add this feature using command-line tools like openocd or STM32_Programmer_CLI . To view ITM output first you should enable SWV ITM console, by selecting it in Window -> Show View -> Other . Next thing is to start to debug the application and when it hits the first breakpoint select Configure trace under SWV ITM console. Select the first three channels and accept. After that you should be ready to go, so just click Start Trace - red dot icon and hit F8 to continue program execution. Now you should see trace debug output like in the picture below.","title":"ITM trace configuration"},{"location":"running/#usb-cdc-configuration","text":"On some platforms (Ubuntu in my case) '/dev/ttyACM*' ports automatically receive AT commands just after plugging USB cable. As we are using raw data format to communicate with TPM device and STM32 CDC port mount as /dev/ACM* device this could be problematic. To stop receiving AT commands just disable ModemManager service with the following command: systemctl stop ModemManager sudo systemctl disable ModemManager","title":"USB CDC configuration"},{"location":"running/#sample-command-execution","text":"As being said, the communication to the TPM core is done using Nucleo's USB CDC Port. In the original implementation VCOM - Windows application was created for this purpose. We choose a different approach and provide several ways to talk to a TPM. Host applications and scripts for experimenting with the protocol are located in ms-tpm-20-ref/Samples/Nucleo-TPM/scripts directory. scripts | lpntpn_cmd - main python script for tpm communication | see ./lpntpn_cmd --help for more info | README.md | simulator - serial port simulator for future protocol | and tpm2-tools/tpm2-tss anallisis | | tpm2-pytss_example - simple startup example using tpm2-pytss library | \u2514\u2500\u2500\u2500tpm2-tts_example - simple startup example using tpm2-tss library | \u2514\u2500\u2500\u2500utils For now only lpntpn_cmd is able to execute its full commands without any errors. pytss and tss examples were created for future communication with tpm device and right now are failing, probably due to not implemented pool functionality in tty kernel driver. More on that on Current issues page. At the moment of writing, only startup and shutdown commands were implemented. As the original implementation adds some redundant data to the protocol, --legacy | --no-legacy arguments were added to lpntpn_cmd application, to allow the user to send VCOM compatible legacy commands. Reception of such legacy commands requires commenting out #define NEW_SIGNAL_HANDLING macro in main.c file, as it is defined by default. Otherwise simple call to ./lpntpn_cmd should be enough to be able to execute startup command on lpntpn. Before running host-side applications, you should flash and start STM32 binary, with debug prints reception enabled with ITM ports 0,1,2 as mentioned in ITM trace configuration Succesfull execution, should result in the following console output: $ ./lpntpn_cmd running in non legacy mode... on /dev/ttyACM1 serial port... executing startup command... sending: b'\\x80\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x01D\\x00\\x00' waiting for response... received: bytearray(b'\\x80\\x01\\x00\\x00\\x00\\n\\x00\\x00\\x01\\x00') And following output in SWV ITM Data window ITM port 0: ========================= = Nucleo-L476RG TPM 2.0 = ========================= 2000.01.02-10:10:40.441GMT: Generated tpmUnique 875fcea802b97786efd69cb3c1f1371b 70d465d97b8c52532c3ba603f2fa571b ef6c44634a2910b303ef92a5d05a59f8 adbc978cca2f2f9874b4e5a2216c10ec 2000.01.02-10:10:40.573GMT: NVFile loaded (16kb, 2000.01.01-03:23:25GMT created, 84 writes, 2000.01.02-10:02:27GMT last) 2000.01.02-10:10:40.576GMT: _plat__SetNvAvail(). 2000.01.02-10:10:40.576GMT: _plat__Signal_PowerOn(). 2000.01.02-10:10:40.576GMT: _plat__Signal_Reset(). 2000.01.02-10:10:40.711GMT: NVFile loaded (16kb, 2000.01.01-03:23:25GMT created, 84 writes, 2000.01.02-10:02:27GMT last) 2000.01.02-10:10:40.714GMT: CDC_SET_LINE_CODING: 9600-8N1 2000.01.02-10:10:51.507GMT: CDC_SET_CONTROL_LINE_STATE: RTS=1, DTR=1 2000.01.02-10:10:51.507GMT: CDC_SET_LINE_CODING: 115200-7N2 2000.01.02-10:10:51.723GMT: Executing command TPM_CC_Startup() 2000.01.02-10:10:52.306GMT: NVFile written (16kb, 2000.01.01-03:23:25GMT created, 85 writes, 2000.01.02-10:10:52GMT last) 2000.01.02-10:10:52.309GMT: Completion time 0'1\" with ReturnCode {TPM_RC_SUCCESS} 2000.01.02-10:10:52.315GMT: CDC_SET_CONTROL_LINE_STATE: RTS=0, DTR=0 ITM port 1: 2000.01.02-10:10:51.723GMT: SignalCommand(12) 2000.01.02-10:10:52.309GMT: Response(10) ITM port 2: //2000.01.02-10:10:51.723GMT unsigned char CmdBuf[12] = { 0x80, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00 }; //2000.01.02-10:10:52.309GMT unsigned char RspBuf[10] = { 0x80, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00 }; An example, changing command type, serial port, and enabling legacy mode. ./lpntpn_cmd --port /dev/ttyACM0 --command shutdown --legacy running in legacy mode... on /dev/ttyACM0 serial port... executing shutdown command... sending: b'Tpm2\\x06\\x00\\x00\\x00\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x80\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x01E\\x00\\x00' waiting for response...","title":"Sample command execution"},{"location":"tpm_modules_pinout/","text":"TPM modules pinout This document describes a few different variants of the TPM module pinouts which are available on some of the PC mainboards. This research was made to design a few variants of the TPM modules with the most popular pinouts. In this chapter below, the same pinouts of TPM modules were grouped. The analyzed mainbaords are chosen based on what we have available for testing, but also based on the best sellers positions from the Newegg.com for some of the most recent mainboards. LPC interface LPC was (and still is) the most common interface for the TPM. AsRock Rack X470 D4U, ROMED8-2T Server MB, EPC621D8A, H170M PRO4 Below there are two different pinouts that could be treated as interchangeable. PCICLK is a 33MHz standard clock (same with CK_33M_TPM). F_CLKRUN# is a signal when asserted instructs chipset to supply a clock signal. On the pinout below it is tied to GND which means always asserted (clock is always running). Manuals: User Manual X470 User Manual ROMED8-2T User Manual EPC621D8A User Manual H170M Asus M5A99FX Pro r2.0, MAXIMUS VII HERO, Z87 PLUS, MAXIMUS VII RANGER Manuals: User Manual M5A99FX User Manual MAXIMUS VII HERO User Manual Z87 PLUS User Manual MAXIMUS VII RANGER Asus MAXIMUS IX FORMULA, CROSSHAIR VIII DARK HERO, ROG STRIX B450-F Gaming Manuals: User Manual MAXIMUS IX FORMULA User Manual ROG CROSSHAIR User Manual B450-F Asus TPM-M R2.0, Z97 PRO GAMER Manuals: User Manual TPM-M User Manual Z97 PRO GAMER Gigabyte GA A320M-S2H AMD A320, GA B250 HD3P, B450 Aorus Pro, GA Z77 D3H, GA 970A-UD3P Below there are two different pinouts that could be treated as interchangeable. SUSCLK is a RTC clock signal which is not used for TPM so it could be ignored. Manuals: User Manual Z77X D3H User Manual Z77 D3H User Manual 970A-UD3P User Manual A320M-S2H User Manual B250 HD3P User Manual B450 AORUS PRO MSI B75MA E33, MSI B85M E45, MSI B350 TOMAHAWK, MSI X99A GAMING 9 ACK Manuals: User Manual B75MA E33 User Manual B85M E45 User Manual TOMAHAWK User Manual X99A Supermicro X10DAL-i, Supermicro MBD M12SWA Below there are two different pinouts that could be treated as interchangeable. Manuals: User Manual Supermicro MBD M12SWA User Manual X10DAL-i SPI interface SPI interface becomes more and more common for TPM modules, especially for the more recent mainboards. We can expect that this interface will be more commonly used in the modern mainbards, as the LPC interface becomes slowly deprecated for modern processors. Asus-B550 PLUS TUF GAMING, Asus-ROG STRIX X570-F GAMING Below there are two different pinouts that could be treated as interchangeable. Manuals: User Manual STRIX X570-F User Manual B550 PLUS MSI Z590 PRO WiFi Manuals: User Manual Z590 Gigabyte Z590 AORUS MASTER Manuals: User Manual Summary There is a relation between TPM modules pinouts at the same vendors. For typical motherboards from one and similar series, pinouts are the same. On the other hand, the same manufacturer also supports different pinouts in the case of different models of motherboards. So it couldn't be said that always the same vendor supports the same pinout. During our research, we have identified: 6 unique LPC TPM pinouts: AsRock (18-pin) Asus (20-pin) Asus (14-pin) Gigabyte (20-pin) MSI (14-pin) Supermicro (20-pin) 3 unique SPI TPM pinouts: Asus (14-pin) MSI (12-pin) Gigabyte (12-pin) These pinouts will be used to define hardware requirements for the TPM boards and, later on, to deisgn TPM adapter boards.","title":"TPM modules pinout"},{"location":"tpm_modules_pinout/#tpm-modules-pinout","text":"This document describes a few different variants of the TPM module pinouts which are available on some of the PC mainboards. This research was made to design a few variants of the TPM modules with the most popular pinouts. In this chapter below, the same pinouts of TPM modules were grouped. The analyzed mainbaords are chosen based on what we have available for testing, but also based on the best sellers positions from the Newegg.com for some of the most recent mainboards.","title":"TPM modules pinout"},{"location":"tpm_modules_pinout/#lpc-interface","text":"LPC was (and still is) the most common interface for the TPM.","title":"LPC interface"},{"location":"tpm_modules_pinout/#asrock-rack-x470-d4u-romed8-2t-server-mb-epc621d8a-h170m-pro4","text":"Below there are two different pinouts that could be treated as interchangeable. PCICLK is a 33MHz standard clock (same with CK_33M_TPM). F_CLKRUN# is a signal when asserted instructs chipset to supply a clock signal. On the pinout below it is tied to GND which means always asserted (clock is always running). Manuals: User Manual X470 User Manual ROMED8-2T User Manual EPC621D8A User Manual H170M","title":"AsRock Rack X470 D4U, ROMED8-2T Server MB, EPC621D8A, H170M PRO4"},{"location":"tpm_modules_pinout/#asus-m5a99fx-pro-r20-maximus-vii-hero-z87-plus-maximus-vii-ranger","text":"Manuals: User Manual M5A99FX User Manual MAXIMUS VII HERO User Manual Z87 PLUS User Manual MAXIMUS VII RANGER","title":"Asus M5A99FX Pro r2.0, MAXIMUS VII HERO, Z87 PLUS, MAXIMUS VII RANGER"},{"location":"tpm_modules_pinout/#asus-maximus-ix-formula-crosshair-viii-dark-hero-rog-strix-b450-f-gaming","text":"Manuals: User Manual MAXIMUS IX FORMULA User Manual ROG CROSSHAIR User Manual B450-F","title":"Asus MAXIMUS IX FORMULA, CROSSHAIR VIII DARK HERO, ROG STRIX B450-F Gaming"},{"location":"tpm_modules_pinout/#asus-tpm-m-r20-z97-pro-gamer","text":"Manuals: User Manual TPM-M User Manual Z97 PRO GAMER","title":"Asus TPM-M R2.0, Z97 PRO GAMER"},{"location":"tpm_modules_pinout/#gigabyte-ga-a320m-s2h-amd-a320-ga-b250-hd3p-b450-aorus-pro-ga-z77-d3h-ga-970a-ud3p","text":"Below there are two different pinouts that could be treated as interchangeable. SUSCLK is a RTC clock signal which is not used for TPM so it could be ignored. Manuals: User Manual Z77X D3H User Manual Z77 D3H User Manual 970A-UD3P User Manual A320M-S2H User Manual B250 HD3P User Manual B450 AORUS PRO","title":"Gigabyte GA A320M-S2H AMD A320, GA B250 HD3P, B450 Aorus Pro, GA Z77 D3H, GA 970A-UD3P"},{"location":"tpm_modules_pinout/#msi-b75ma-e33-msi-b85m-e45-msi-b350-tomahawk-msi-x99a-gaming-9-ack","text":"Manuals: User Manual B75MA E33 User Manual B85M E45 User Manual TOMAHAWK User Manual X99A","title":"MSI B75MA E33, MSI B85M E45, MSI B350 TOMAHAWK, MSI X99A GAMING 9 ACK"},{"location":"tpm_modules_pinout/#supermicro-x10dal-i-supermicro-mbd-m12swa","text":"Below there are two different pinouts that could be treated as interchangeable. Manuals: User Manual Supermicro MBD M12SWA User Manual X10DAL-i","title":"Supermicro X10DAL-i, Supermicro MBD M12SWA"},{"location":"tpm_modules_pinout/#spi-interface","text":"SPI interface becomes more and more common for TPM modules, especially for the more recent mainboards. We can expect that this interface will be more commonly used in the modern mainbards, as the LPC interface becomes slowly deprecated for modern processors.","title":"SPI interface"},{"location":"tpm_modules_pinout/#asus-b550-plus-tuf-gaming-asus-rog-strix-x570-f-gaming","text":"Below there are two different pinouts that could be treated as interchangeable. Manuals: User Manual STRIX X570-F User Manual B550 PLUS","title":"Asus-B550 PLUS TUF GAMING, Asus-ROG STRIX X570-F GAMING"},{"location":"tpm_modules_pinout/#msi-z590-pro-wifi","text":"Manuals: User Manual Z590","title":"MSI Z590 PRO WiFi"},{"location":"tpm_modules_pinout/#gigabyte-z590-aorus-master","text":"Manuals: User Manual","title":"Gigabyte Z590 AORUS MASTER"},{"location":"tpm_modules_pinout/#summary","text":"There is a relation between TPM modules pinouts at the same vendors. For typical motherboards from one and similar series, pinouts are the same. On the other hand, the same manufacturer also supports different pinouts in the case of different models of motherboards. So it couldn't be said that always the same vendor supports the same pinout. During our research, we have identified: 6 unique LPC TPM pinouts: AsRock (18-pin) Asus (20-pin) Asus (14-pin) Gigabyte (20-pin) MSI (14-pin) Supermicro (20-pin) 3 unique SPI TPM pinouts: Asus (14-pin) MSI (12-pin) Gigabyte (12-pin) These pinouts will be used to define hardware requirements for the TPM boards and, later on, to deisgn TPM adapter boards.","title":"Summary"},{"location":"tpm_renders/","text":"The TPM concept According to the many varied pinouts necessary was design the concept of TPM module which can fit the motherboard pinout. There was the consideration of two kinds of the interface (SPI and LPC). The whole setup would be made of two PCBs. One is the main PCB with the MCU and SPI or LPC configured socket and the second is the adapter that fits the motherboards pinouts. Concept of slim adapter Because of limited space on the motherboard, we decided to design the slim variant of the TPM module. Dimensions are shown in the attached graphics below. The main module: The adapter: The assembly: An example of usage with motherboard: Thanks for that design the widest element (connector that connects the whole design with motherboard socket) measures 5mm. That allowed to get slim contour. The length of the design is indicative and might be changed.","title":"TPM modules renders"},{"location":"tpm_renders/#the-tpm-concept","text":"According to the many varied pinouts necessary was design the concept of TPM module which can fit the motherboard pinout. There was the consideration of two kinds of the interface (SPI and LPC). The whole setup would be made of two PCBs. One is the main PCB with the MCU and SPI or LPC configured socket and the second is the adapter that fits the motherboards pinouts.","title":"The TPM concept"},{"location":"tpm_renders/#concept-of-slim-adapter","text":"Because of limited space on the motherboard, we decided to design the slim variant of the TPM module. Dimensions are shown in the attached graphics below.","title":"Concept of slim adapter"},{"location":"tpm_renders/#the-main-module","text":"","title":"The main module:"},{"location":"tpm_renders/#the-adapter","text":"","title":"The adapter:"},{"location":"tpm_renders/#the-assembly","text":"","title":"The assembly:"},{"location":"tpm_renders/#an-example-of-usage-with-motherboard","text":"Thanks for that design the widest element (connector that connects the whole design with motherboard socket) measures 5mm. That allowed to get slim contour. The length of the design is indicative and might be changed.","title":"An example of usage with motherboard:"}]}